// Autogenerated from Pigeon (v4.1.0), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation
#if os(iOS)
import Flutter
#elseif os(macOS)
import FlutterMacOS
#else
#error("Unsupported platform.")
#endif


/// Generated class from Pigeon.

///Generated class from Pigeon that represents data sent in messages.
struct Book {
  var title: String? = nil
  var author: Author? = nil

  static func fromMap(_ map: [String: Any?]) -> Book? {
    let title = map["title"] as? String 
    var author: Author? = nil
    if let authorMap = map["author"] as? [String: Any?] {
      author = Author.fromMap(authorMap)
    }

    return Book(
      title: title,
      author: author
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "title": title,
      "author": author?.toMap()
    ]
  }
}

///Generated class from Pigeon that represents data sent in messages.
struct Author {
  var name: String? = nil
  var age: Int32? = nil

  static func fromMap(_ map: [String: Any?]) -> Author? {
    let name = map["name"] as? String 
    let age = map["age"] as? Int32 

    return Author(
      name: name,
      age: age
    )
  }
  func toMap() -> [String: Any?] {
    return [
      "name": name,
      "age": age
    ]
  }
}

private class HostBookApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return Author.fromMap(self.readValue() as! [String: Any])      
      case 129:
        return Book.fromMap(self.readValue() as! [String: Any])      
      default:
        return super.readValue(ofType: type)
      
    }
  }
}
private class HostBookApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? Author {
      super.writeByte(128)
      super.writeValue(value.toMap())
    } else if let value = value as? Book {
      super.writeByte(129)
      super.writeValue(value.toMap())
    } else {
      super.writeValue(value)
    }
  }
}

private class HostBookApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return HostBookApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return HostBookApiCodecWriter(data: data)
  }
}

class HostBookApiCodec: FlutterStandardMessageCodec {
  static let shared = HostBookApiCodec(readerWriter: HostBookApiCodecReaderWriter())
}

///Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol HostBookApi {
  func search(keyword: String) -> [Book]
  func asyncSearch(keyword: String, completion: @escaping ([Book]) -> Void)
  func searchWithTitle(title: String, completion: @escaping (Author) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class HostBookApiSetup {
  /// The codec used by HostBookApi.
  static var codec: FlutterStandardMessageCodec { HostBookApiCodec.shared }
  /// Sets up an instance of `HostBookApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: HostBookApi?) {
    let searchChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.HostBookApi.search", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      searchChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let keywordArg = args[0] as! String
        let result = api.search(keyword: keywordArg)
        reply(wrapResult(result))
      }
    } else {
      searchChannel.setMessageHandler(nil)
    }
    let asyncSearchChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.HostBookApi.asyncSearch", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      asyncSearchChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let keywordArg = args[0] as! String
        api.asyncSearch(keyword: keywordArg) { result in
          reply(wrapResult(result))
        }
      }
    } else {
      asyncSearchChannel.setMessageHandler(nil)
    }
    let searchWithTitleChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.HostBookApi.searchWithTitle", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      searchWithTitleChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let titleArg = args[0] as! String
        api.searchWithTitle(title: titleArg) { result in
          reply(wrapResult(result))
        }
      }
    } else {
      searchWithTitleChannel.setMessageHandler(nil)
    }
  }
}
private class FlutterBookApiCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
      case 128:
        return Author.fromMap(self.readValue() as! [String: Any])      
      case 129:
        return Book.fromMap(self.readValue() as! [String: Any])      
      default:
        return super.readValue(ofType: type)
      
    }
  }
}
private class FlutterBookApiCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? Author {
      super.writeByte(128)
      super.writeValue(value.toMap())
    } else if let value = value as? Book {
      super.writeByte(129)
      super.writeValue(value.toMap())
    } else {
      super.writeValue(value)
    }
  }
}

private class FlutterBookApiCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return FlutterBookApiCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return FlutterBookApiCodecWriter(data: data)
  }
}

class FlutterBookApiCodec: FlutterStandardMessageCodec {
  static let shared = FlutterBookApiCodec(readerWriter: FlutterBookApiCodecReaderWriter())
}

///Generated class from Pigeon that represents Flutter messages that can be called from Swift.
class FlutterBookApi {
  private let binaryMessenger: FlutterBinaryMessenger
  init(binaryMessenger: FlutterBinaryMessenger){
    self.binaryMessenger = binaryMessenger
  }
  var codec: FlutterStandardMessageCodec {
    return FlutterBookApiCodec.shared
  }
  func displayBookDetails(book bookArg: Book, completion: @escaping () -> Void) {
    let channel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.FlutterBookApi.displayBookDetails", binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([bookArg]) { _ in
      completion()
    }
  }
}

private func wrapResult(_ result: Any?) -> [String: Any?] {
  return ["result": result]
}

private func wrapError(_ error: FlutterError) -> [String: Any?] {
  return [
    "error": [
      "code": error.code,
      "message": error.message,
      "details": error.details
    ]
  ]
}
